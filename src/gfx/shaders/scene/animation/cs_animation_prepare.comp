// Joint animation preparation shader.
//
// Emits compute dispatches for each animated instance with
// a non-zero active animation count.
#version 460

#extension GL_GOOGLE_include_directive : enable

#define CS_MAIN csPrepareAnimations

#include "../../as_include_head.glsl"

#include "../group/as_group.glsl"

#include "../instance/as_instance.glsl"

#include "../renderpass/as_renderpass.glsl"

#include "../as_scene.glsl"

#include "as_animation.glsl"

// Match the instance update preparation workgroup size so that
// we can use the same parameter buffer
layout(local_size_x = PASS_GROUP_WORKGROUP_SIZE) in;


// Shader arguments. Stores buffer pointers to read data from.
layout(push_constant)
uniform CsPushData {
  InstanceNodeBuffer    instanceNodeBuffer;
  uint64_t              groupVa;
  uint32_t              frameId;
} globals;


// Helper function to work out whether the instance even has
// animations enabled, and to compute the dispatch workgroup
// count as necessary.
struct CsInvocationOutput {
  uint32_t              instanceNodeRef;
  uint32_t              workgroupCount;
};

uint32_t csGetInstanceNodeRef() {
  uint32_t gid = gl_GlobalInvocationID.x;

  // Exit early if the thread ID is out of bounds
  PassGroupBuffer group = PassGroupBuffer(globals.groupVa);

  PassGroupNodeListIn nodeList = PassGroupNodeListIn(globals.groupVa +
    group.nodeListOffsets[NODE_TYPE_INSTANCE - NODE_TYPE_BUILTIN_COUNT].nodeList);

  if (gid >= nodeList.header.entryCount)
    return 0u;

  // Load instance properties and check whether we need to update it.
  uint32_t instanceNodeRef = nodeList.items[gid].nodeRef;
  uint32_t instanceIndex = getNodeIndexFromRef(instanceNodeRef);
  InstanceNode instance = globals.instanceNodeBuffer.nodes[instanceIndex];

  // Exit early if the instance in question has already been updated.
  uint32_t updateFrameId = instance.updateFrameId;

  if (updateFrameId >= globals.frameId)
    return 0u;

  // Exit early if the instance does not have animations or is not resident
  if ((instance.flags & INSTANCE_ANIMATION_BIT) == 0u)
    return 0u;

  // Exit if the geometry buffer of the animation is not defined
  InstanceHeader instanceInfo = InstanceDataBufferIn(instance.propertyBuffer).header;

  if (instanceInfo.geometryVa == 0ul)
    return 0u;

  // Exit early if the instance does not have any active animations
  InstanceAnimationBufferIn animationBuffer = instanceGetAnimationProperties(instance.propertyBuffer);

  if (animationBuffer.header.animationCount == 0u)
    return 0u;

  // The instance does have active animations
  return instanceNodeRef;
}


void csPrepareAnimations() {
  uint32_t instanceNodeRef = csGetInstanceNodeRef();

  if (instanceNodeRef != 0u)
    nodeListAddUpdate(globals.groupVa, instanceNodeRef, 0, 1);
}


#include "../../as_include_tail.glsl"
