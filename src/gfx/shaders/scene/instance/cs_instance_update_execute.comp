// Instance update preparation shader. Used to submit stream requests
// and instance update requests as necessary, using one workgroup per
// visible instance.
#version 460

#extension GL_GOOGLE_include_directive : enable

#define CS_MAIN csExecuteUpdate

#include "../../as_include_head.glsl"

#include "../group/as_group.glsl"

#include "../renderpass/as_renderpass.glsl"

#include "../as_scene.glsl"

#include "as_instance.glsl"

layout(local_size_x_id = SPEC_CONST_ID_MIN_SUBGROUP_SIZE) in;

const uint CsJointCacheSize = CsMinSubgroupSize;

// Useful constants for some compile-time subgroup optimizations
bool IsSingleSubgroup = (gl_NumSubgroups == 1);

layout(push_constant)
uniform PushData {
  InstanceNodeBufferIn  instanceBuffer;
  uint64_t              groupBuffer;
} globals;


// Helper function to compute the axis-aligned bounding box for
// the geometry instance by reducing the coordinate vectors.
shared Aabb csAabbShared;

Aabb csAccumulateAabb(Aabb aabb) {
  aabb.lo = subgroupMin(aabb.lo);
  aabb.hi = subgroupMax(aabb.hi);

  if (!IsSingleSubgroup) {
    // We shouldn't ever hit this code path in practice, but drivers
    // may be weird and not launch the shader with full subgroups.
    if (gl_SubgroupID == 0) {
      if (subgroupElect())
        csAabbShared = aabb;
    }

    barrier();

    // Ignore performance and just do something that works without
    // requiring weird features like atomic floats.
    for (uint i = 1; i < gl_NumSubgroups; i++) {
      if (gl_SubgroupID == i) {
        if (subgroupElect()) {
          csAabbShared.lo = min(aabb.lo, csAabbShared.lo);
          csAabbShared.hi = max(aabb.hi, csAabbShared.hi);
        }
      }

      barrier();
    }

    aabb = csAabbShared;
  }

  return aabb;
}


// Computes transform for a single joint. This is equivalent to
// translating a vertex into joint space, applying the relative
// transform, and then translating back into model space.
Transform csComputeJointTransform(in Transform jointTransform, vec3 jointPosition) {
  Transform localTransform;
  localTransform.rot = jointTransform.rot;
  localTransform.pos = jointTransform.pos + quatApplyNorm(jointTransform.rot, -jointPosition) + jointPosition;
  return localTransform;
}


// Computes the absolute transform for a joint by chaining
// it with the absolute transform of its parent joint.
Transform csComputeAbsoluteTransform(in Transform parentTransform, in Transform jointTransform) {
  return transChainNorm(parentTransform, jointTransform);
}


// Computes absolute transforms for the jointCount joints defined in
// the joints buffer, using relative transforms from the input buffer,
// and writes the final transforms to the result buffer. Must be called
// from uniform control flow within the workgroup.
shared Transform csTransformJointOutputCache[CsJointCacheSize];

shared uint csTransformJointCountShared;

void csTransformJoints(in GeometryRef geometryBuffer, uint64_t instanceBuffer, uint32_t hostSetOffset) {
  Geometry geometry = geometryBuffer.geometry;
  JointRef jointBuffer = geometryGetJointData(geometryBuffer, geometry);

  Aabb aabb = Aabb(
    vec3(geometry.aabb.lo),
    vec3(geometry.aabb.hi));

  uint firstJoint = 0;
  uint firstCachedOutput = 0;

  while (firstJoint < geometry.jointCount) {
    Joint joint;

    // Check whether the current joint index is valid, and if it is,
    // whether the joint has a dependency on the current iteration.
    uint jointIndex = firstJoint + gl_LocalInvocationIndex;
    bool canCompute = jointIndex < geometry.jointCount;

    if (canCompute) {
      joint = jointBuffer.joints[jointIndex];

      canCompute = (joint.parent >= geometry.jointCount)
                || (joint.parent <  firstJoint);
    }

    // Count joints to process in this iteration
    uint count = subgroupBallotBitCount(subgroupBallot(canCompute));

    if (!IsSingleSubgroup) {
      if (gl_LocalInvocationIndex == 0)
        csTransformJointCountShared = 0;

      barrier();

      if (subgroupElect())
        atomicAdd(csTransformJointCountShared, count);

      barrier();

      // Don't need a barrier after the read since
      // we'll be doing another one later anyway
      count = csTransformJointCountShared;
    }

    Transform jointTransform;

    if (canCompute) {
      // Load relative transform from input buffer.
      Transform relativeTransform = instanceLoadRelativeJoint(instanceBuffer, hostSetOffset, jointIndex);

      // Compute transform for the current joint.
      jointTransform = csComputeJointTransform(relativeTransform, joint.position);

      // If necessary, load parent transform from output buffer and use
      // it to compute the absolute transform for the current joint.
      if (joint.parent < firstJoint) {
        Transform parentTransform;

        if (joint.parent < firstCachedOutput)
          parentTransform = instanceLoadJoint(instanceBuffer, 0, joint.parent);
        else
          parentTransform = csTransformJointOutputCache[joint.parent - firstCachedOutput];

        jointTransform = csComputeAbsoluteTransform(parentTransform, jointTransform);
      }

      // Adjust the bounding box as necessary.
      vec3 absolutePosition = joint.position + jointTransform.pos;

      float radius = quatGetScale(jointTransform.rot) * float(joint.radius)
                   + length(relativeTransform.pos);

      aabb.lo = min(aabb.lo, absolutePosition - radius);
      aabb.hi = max(aabb.hi, absolutePosition + radius);
    }

    if (firstJoint + count < geometry.jointCount) {
      // Insert barrier between potentially reading from LDS and writing
      // to it again in order to prevent a write-after-read hazard here.
      barrier();

      if (canCompute) {
        // Cache output transform in LDS so that the next iteration can access
        // the data without having to read memory. We should only hit the memory
        // path if the number of joints we can compute in parallel is larger
        // than the workgroup size, which should be extremely rare.
        csTransformJointOutputCache[gl_LocalInvocationIndex] = jointTransform;
      }
    }

    // Store final result in output buffer.
    if (canCompute)
      instanceStoreJoint(instanceBuffer, 0, jointIndex, jointTransform);

    // If there are any joints left to process, make sure writes
    // to the output buffer are visible to the entire workgroup.
    if (firstJoint + count < geometry.jointCount) {
      controlBarrier(gl_ScopeWorkgroup, gl_ScopeWorkgroup,
        gl_StorageSemanticsShared | gl_StorageSemanticsBuffer,
        gl_SemanticsAcquireRelease);
    }

    // Advance to next iteration
    firstCachedOutput = firstJoint;
    firstJoint += count;
  }

  // Broadcast AABB to whole workgroup
  aabb = csAccumulateAabb(aabb);

  if (gl_LocalInvocationIndex == 0) {
    instanceStoreAabb(instanceBuffer,
      Aabb16(f16vec3(aabb.lo), f16vec3(aabb.hi)));
  }
}

void csUpdateDeform(in InstanceNode instanceNode) {
  InstanceHeader instanceInfo = InstanceDataBuffer(instanceNode.propertyBuffer).header;

  // Exit early if the geometry buffer is not resident
  if (instanceInfo.geometryVa == 0ul)
    return;

  // If animations are enabled for the instance but none are currently
  // defined as active, read the app-defined data directly.
  uint32_t hostSetOffset = 0u;

  if (instanceInfo.animationCount != 0u) {
    InstanceAnimationBufferIn animationParameters = instanceGetAnimationProperties(instanceNode.propertyBuffer);
    hostSetOffset = animationParameters.header.animationCount == 0u ? 1u : 0u;
  }

  // Copy current absolute joint transforms to previous frame's array
  for (uint i = 0; i < instanceInfo.jointCount; i += gl_WorkGroupSize.x) {
    uint32_t index = i + gl_LocalInvocationIndex;

    if (index < instanceInfo.jointCount) {
      Transform transform = instanceLoadJoint(instanceNode.propertyBuffer, 0, index);
      instanceStoreJoint(instanceNode.propertyBuffer, 1, index, transform);
    }
  }

  // Compute absolute joint transforms for the current frame
  if (instanceInfo.jointCount > 0)
    csTransformJoints(GeometryRef(instanceInfo.geometryVa), instanceNode.propertyBuffer, hostSetOffset);

  // Copy current absolute joint transforms to previous frame's array
  for (uint i = 0; i < instanceInfo.weightCount; i += gl_WorkGroupSize.x) {
    uint32_t index = i + gl_LocalInvocationIndex;

    if (index < instanceInfo.weightCount) {
      int16_t curr = instanceLoadMorphTargetWeight(instanceNode.propertyBuffer, 2u + hostSetOffset, index);
      int16_t prev = instanceLoadMorphTargetWeight(instanceNode.propertyBuffer, 0u, index);

      instanceStoreMorphTargetWeight(instanceNode.propertyBuffer, 0, index, curr);
      instanceStoreMorphTargetWeight(instanceNode.propertyBuffer, 1, index, prev);
    }
  }
}


void csUpdateAssets(in InstanceNode instanceNode) {
  InstanceHeader instanceInfo = InstanceDataBuffer(instanceNode.propertyBuffer).header;
  AssetListBufferIn assetList = AssetListBufferIn(instanceNode.assetListBuffer);

  // Use two different buffer types to write resource parameters. This
  // may enable a fast path when writing buffer addresses on some drivers.
  InstanceRawBufferOut32 instanceData32 = InstanceRawBufferOut32(instanceNode.propertyBuffer);
  InstanceRawBufferOut64 instanceData64 = InstanceRawBufferOut64(instanceNode.propertyBuffer);

  InstanceResourceBufferIn resourceBuffer = InstanceResourceBufferIn(instanceNode.propertyBuffer + instanceInfo.resourceOffset);

  // The indirection data offset is not stored anywhere, we need to compute it manually.
  InstanceResourceIndirectionBufferIn indirectionBuffer = InstanceResourceIndirectionBufferIn(instanceNode.propertyBuffer + instanceInfo.indirectionOffset);

  // Ensure that it is safe to dereference the asset list pointer. If not,
  // default to null pointers and invalid descriptor indices when needed.
  bool hasAssetList = instanceNode.assetListBuffer != uint64_t(0u);

  for (uint32_t i = 0; i < instanceInfo.indirectionCount; i += gl_WorkGroupSize.x) {
    uint32_t index = i + gl_LocalInvocationIndex;

    if (index < instanceInfo.indirectionCount) {
      InstanceResourceIndirection indirection = indirectionBuffer.entries[index];

      // Interpret the 64-bit encoded entry. If the least significant bit is
      // set, the upper 32 bits store an index into the asset list.
      uvec2 srcData = resourceBuffer.entries[uint32_t(indirection.srcEntry)];
      bool useAssetList = (srcData.x & 1) != 0;

      if (uint32_t(indirection.type) == INSTANCE_RESOURCE_TYPE_BUFFER_ADDRESS) {
        uvec2 dstData = srcData;

        if (useAssetList) {
          dstData = uvec2(0u, 0u);

          if (hasAssetList) {
            dstData = uvec2(
              assetList.dwords[srcData.y + 0u],
              assetList.dwords[srcData.y + 1u]);
          }
        }

        instanceData64.data[indirection.dstOffset / 8u] = dstData;
      } else {
        uint32_t dstData = srcData.y;

        if (useAssetList) {
          dstData = ~0u;

          if (hasAssetList)
            dstData = assetList.dwords[srcData.y + 0u];
        }

        instanceData32.data[indirection.dstOffset / 4u] = dstData;
      }
    }
  }

  // Ensure that we can properly read the geometry buffer address later
  controlBarrier(gl_ScopeWorkgroup, gl_ScopeWorkgroup,
    gl_StorageSemanticsBuffer, gl_SemanticsAcquireRelease);
}


void csExecuteUpdate() {
  PassGroupUpdateListIn instanceList = getNodeTypeUpdateList(globals.groupBuffer, NODE_TYPE_INSTANCE);

  uint32_t workgroupId = asFlattenWorkgroupIndex();

  if (workgroupId >= instanceList.header.entryCount)
    return;

  uint32_t nodeRef = instanceList.nodeRefs[workgroupId];
  uint32_t dirtyFlags = getNodeTypeFromRef(nodeRef) << INSTANCE_DIRTY_SHIFT;
  uint32_t instanceIndex = getNodeIndexFromRef(nodeRef);

  // Update assets first since this may make the geometry buffer resident
  InstanceNode instanceNode = globals.instanceBuffer.nodes[instanceIndex];

  if ((dirtyFlags & INSTANCE_DIRTY_ASSETS_BIT) != 0)
    csUpdateAssets(instanceNode);

  if ((dirtyFlags & INSTANCE_DIRTY_DEFORM_BIT) != 0)
    csUpdateDeform(instanceNode);
}

#include "../../as_include_tail.glsl"
